<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树与二叉树 | XDU 953 House</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/img/leaf.ico">
    <link rel="stylesheet" href="/css/katex0.15.1.min.css">
    <script src="/js/katex0.15.1.min.js"></script>
    <script src="/js/jquery1.9.1.min.js"></script>
    <script src="/js/crypto.js"></script>
    <script src="/js/md5.js"></script>
    <link rel="stylesheet" href="/css/button.css">
    <meta name="description" content="片刻寧靜">
    
    <link rel="preload" href="/assets/css/0.styles.dee84450.css" as="style"><link rel="preload" href="/assets/js/app.464b2a28.js" as="script"><link rel="preload" href="/assets/js/2.f539a802.js" as="script"><link rel="preload" href="/assets/js/1.74843084.js" as="script"><link rel="preload" href="/assets/js/11.e4895d61.js" as="script"><link rel="prefetch" href="/assets/js/10.921445e1.js"><link rel="prefetch" href="/assets/js/12.cba02928.js"><link rel="prefetch" href="/assets/js/13.b4fea8f9.js"><link rel="prefetch" href="/assets/js/14.eb0bf0f2.js"><link rel="prefetch" href="/assets/js/15.2f4cbb95.js"><link rel="prefetch" href="/assets/js/16.ca772779.js"><link rel="prefetch" href="/assets/js/17.1f24fd4d.js"><link rel="prefetch" href="/assets/js/18.84ef48e2.js"><link rel="prefetch" href="/assets/js/19.f8969fd3.js"><link rel="prefetch" href="/assets/js/20.eac09a2e.js"><link rel="prefetch" href="/assets/js/21.0d2dbedb.js"><link rel="prefetch" href="/assets/js/22.cc515833.js"><link rel="prefetch" href="/assets/js/23.dd83e4f1.js"><link rel="prefetch" href="/assets/js/24.56d64ff8.js"><link rel="prefetch" href="/assets/js/25.1c0c1474.js"><link rel="prefetch" href="/assets/js/26.0a2297ed.js"><link rel="prefetch" href="/assets/js/27.5f1af55f.js"><link rel="prefetch" href="/assets/js/28.96a2e9b9.js"><link rel="prefetch" href="/assets/js/29.04313390.js"><link rel="prefetch" href="/assets/js/3.f3113a3f.js"><link rel="prefetch" href="/assets/js/30.7c04ffad.js"><link rel="prefetch" href="/assets/js/31.c10c8375.js"><link rel="prefetch" href="/assets/js/32.683356de.js"><link rel="prefetch" href="/assets/js/33.7269e8ba.js"><link rel="prefetch" href="/assets/js/34.7f4a41b2.js"><link rel="prefetch" href="/assets/js/35.2d2e1c38.js"><link rel="prefetch" href="/assets/js/36.9e5c5ff7.js"><link rel="prefetch" href="/assets/js/37.15da9b29.js"><link rel="prefetch" href="/assets/js/38.12fc08d8.js"><link rel="prefetch" href="/assets/js/39.6bb478b3.js"><link rel="prefetch" href="/assets/js/4.4d73d019.js"><link rel="prefetch" href="/assets/js/40.7bd5e9df.js"><link rel="prefetch" href="/assets/js/41.9992730b.js"><link rel="prefetch" href="/assets/js/42.b9ea5cbd.js"><link rel="prefetch" href="/assets/js/43.1830ed9e.js"><link rel="prefetch" href="/assets/js/44.e8fff894.js"><link rel="prefetch" href="/assets/js/45.81ab4634.js"><link rel="prefetch" href="/assets/js/46.819b1ad8.js"><link rel="prefetch" href="/assets/js/47.780e3064.js"><link rel="prefetch" href="/assets/js/48.86771a41.js"><link rel="prefetch" href="/assets/js/49.ff389619.js"><link rel="prefetch" href="/assets/js/5.f4693a95.js"><link rel="prefetch" href="/assets/js/50.2b8165da.js"><link rel="prefetch" href="/assets/js/51.536d1912.js"><link rel="prefetch" href="/assets/js/52.66e9128b.js"><link rel="prefetch" href="/assets/js/53.0607ace0.js"><link rel="prefetch" href="/assets/js/54.e44d762a.js"><link rel="prefetch" href="/assets/js/55.7ba6d36e.js"><link rel="prefetch" href="/assets/js/56.015bc6c9.js"><link rel="prefetch" href="/assets/js/57.6935f8e2.js"><link rel="prefetch" href="/assets/js/58.b7045388.js"><link rel="prefetch" href="/assets/js/6.f2c56be6.js"><link rel="prefetch" href="/assets/js/7.992cee86.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.d63322e5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dee84450.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/error.jpg" alt="XDU 953 House" class="logo"> <span class="site-name can-hide">XDU 953 House</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/ds/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/cn/" class="nav-link">
  计算机网络
</a></div><div class="nav-item"><a href="/crypto/" class="nav-link">
  密码学
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/ds/" class="nav-link router-link-active">
  数据结构
</a></div><div class="nav-item"><a href="/cn/" class="nav-link">
  计算机网络
</a></div><div class="nav-item"><a href="/crypto/" class="nav-link">
  密码学
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据结构基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ds/basics/data-structure-sequence.html" class="sidebar-link">绪论和线性表</a></li><li><a href="/ds/basics/data-structure-stack-queue-array-string.html" class="sidebar-link">栈、队列、数组和串</a></li><li><a href="/ds/basics/data-structure-forest-binary-tree.html" aria-current="page" class="active sidebar-link">树与二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#树的定义" class="sidebar-link">树的定义</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#二叉树的高度、结点及度" class="sidebar-link">二叉树的高度、结点及度</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#深度优先" class="sidebar-link">深度优先</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#非递归遍历" class="sidebar-link">非递归遍历</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#宽度优先" class="sidebar-link">宽度优先</a></li></ul></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#由序列构造二叉树" class="sidebar-link">由序列构造二叉树</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#线索二叉树" class="sidebar-link">线索二叉树</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#树、森林和二叉树" class="sidebar-link">树、森林和二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#树和森林的表示和转化" class="sidebar-link">树和森林的表示和转化</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#树和森林的遍历" class="sidebar-link">树和森林的遍历</a></li></ul></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#树和二叉树的应用" class="sidebar-link">树和二叉树的应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#哈夫曼树" class="sidebar-link">哈夫曼树</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#哈夫曼编码" class="sidebar-link">哈夫曼编码</a></li><li class="sidebar-sub-header"><a href="/ds/basics/data-structure-forest-binary-tree.html#并查集" class="sidebar-link">并查集</a></li></ul></li></ul></li><li><a href="/ds/basics/data-structure-graph.html" class="sidebar-link">图</a></li><li><a href="/ds/basics/data-structure-search.html" class="sidebar-link">查找</a></li><li><a href="/ds/basics/data-structure-sort.html" class="sidebar-link">排序</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库系统概论</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>二叉树的性质、遍历过程，树、森林的二叉化（孩子兄弟表示法），哈夫曼树的性质及应用，并查集的概念（双亲表示法）</p> <h2 id="树的定义">树的定义</h2> <p>树的定义是递归的，因为你发现，树的孩子仍是一棵树，所以我们说树是一种递归的<strong>逻辑结构</strong></p> <p>节点的孩子个数叫做该节点的度，树的度为最大的度，<strong>树的节点数等于树的度数加一</strong>，叶子节点的度为 0</p> <p>树的深度和高度从 1 计数</p> <ul><li>树的深度为从上往下</li> <li>树的高度为从下往上</li></ul> <p>树的路径长度等于所有<strong>路径长度的总和</strong>（一条边长度为 1），并非最大</p> <p>有序树和无序树，这里的顺序指从左往右的顺序，即左子树和右子树调换位置，若树不变，则为无序树</p> <img src="/assets/img/image-20230525014538690.76e318cc.png"> <p>树的顺序存储和链式存储：<strong>顺寻储存时要把最后一层全部补上空值</strong>，即使最后一层只有一个结点元素，也要把剩下的全补全，这样树才能<strong>不失唯一性</strong></p> <p>对于完全 m 叉树，其顺序存储下，下标 i 的结点的第一个孩子结点的下标为
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>j</mi><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">
j = (i-1)\times m + 2
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></eqn></section>
反过来，对于下标为 j 的结点，其父节点下标为
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>j</mi><mo>−</mo><mn>2</mn></mrow><mi>m</mi></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
i = \lfloor \frac{j-2}{m}\rfloor + 1
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0225em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></eqn></section>
m 叉树在顺序存储下父子结点和下标的关系映射</p> <img src="/assets/img/image-20230526021945562.8403a9b9.png"> <h2 id="二叉树的高度、结点及度">二叉树的高度、结点及度</h2> <blockquote><p>求解二叉树的结点数，一定要牢抓度和结点的关系：<code>n0 = n2+2</code></p> <p>另外对于特殊情况，直接画出来不失为一种好的方法，或者找一种及其特殊的符合题意的二叉树，把答案看出来</p></blockquote> <p>树的“三多”：叶子比分支多一个；空链比结点多一个；结点比边多一个</p> <p>二叉树的叶子节点（度为 0）和分支节点（度为 2）数量上一定满足
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">
n_2+1 = n_0
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></eqn></section>
即叶子节点个数总比分支节点多一个，这是为什么呢？因为树的度数加一为节点个数，对于二叉树，有
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>0</mn></msub><mo>→</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">
2n_2+n_1 = n_2+n_1+n_0\rightarrow n_2+1=n_0
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></eqn></section>
二叉树的空链数一定等于结点数加一，证明如下：由上已知<code>n2 = n0-1</code>，则结点数 n 为
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
n = n_2+n_1+n_0 = n_1 + 2n_0 - 1
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></eqn></section>
空连只存在于 n1 和 n0 上，故空链数 m 为
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">
m = n_1 + 2n_0
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></eqn></section>
故有<code>m = n+1</code>，即空链数等于结点数加一</p> <p>另外，树的结点数一定比边多一个，这是一定的，树是一个简单连通无向图，所有结点间均通过一条边相连，故结点数比边数多一</p> <p>特殊的二叉树</p> <ul><li>满二叉树：叶子节点全分布在最后一层</li> <li>完全二叉树：顺序存储下和满二叉树保持一致，<strong>但不一定满</strong>，即最后一层从左往右排布不全</li></ul> <p>在转化为顺序存储后，下标为 i 的结点的左孩子下标为 2i，右孩子为 2i+1（当然前提是孩子节点存在），相应的，下标为 j 的结点，其父节点下标为
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>j</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">
i = \lfloor \frac{j}{2}\rfloor
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0225em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></span></eqn></section>
对于满二叉树（完全二叉树），第 k 层最多有
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
2^{k-1}
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8991em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></eqn></section>
个元素，对于<code>1~k-1</code>层，共有
<section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
2^{k-1}-1
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></eqn></section>
个元素，容易发现，下一层的元素数量是上层元素总和再加一（指数增长）</p> <p>完全二叉树中，对于度为 1 的结点，只有两种情况，要么为 0，要么为 1（很容易想通），所以有的时候<strong>问完全二叉树最多最少</strong>的时候，就差这么一个度为 1 的结点</p> <p>顺序存储下，找二叉树子树的最近公共祖先结点</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">ancestor</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
            i <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            j <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><img src="/assets/img/image-20230526020839832.c93fce88.png"> <p>注意 A 的说法，是父节点的左兄弟节点，不是自己的左兄弟，是正确的；D 没有交代 2i 是否存在</p> <img src="/assets/img/image-20230526021043724.1b6e5d6d.png"> <p>不明白捏，选 C</p> <img src="/assets/img/image-20230526020730262.94451278.png"> <img src="/assets/img/image-20230526020701535.3d2b20be.png"> <p>注意 10 和 21 的区别，一个最少一个最多，后者比前者多一层</p> <p>树的高度和结点数的关系（合理取对数，向上/下取整）</p> <img src="/assets/img/image-20230526021819332.8854e26e.png"> <h2 id="二叉树的遍历">二叉树的遍历</h2> <h3 id="深度优先">深度优先</h3> <p>深度优先遍历（前序遍历），其实结点的递归顺序都一样，前序、中序、后序只是<strong>触发<code>visit</code>的时机不同而已</strong></p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>BiTNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 前序遍历</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>计算叶结点带权路径总和</p> <img src="/assets/img/image-20230529001137028.4c634668.png"> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TNode</span><span class="token punctuation">{</span>
   <span class="token keyword">double</span> weight<span class="token punctuation">;</span>
    TNode <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>TNode<span class="token punctuation">;</span>

<span class="token keyword">double</span> wpl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> deep<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> n<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        wpl <span class="token operator">+=</span> n<span class="token operator">-&gt;</span>weight<span class="token operator">*</span>deep<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> deep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">weight</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> wpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>中序递归遍历实现中缀表达式转化</p> <img src="/assets/img/image-20230529001502264.36ff597f.png"> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
    chat data<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我的解法如下</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>string expression <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//空直接返回</span>
    <span class="token comment">// 叶子结点直接接上表达式</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> n<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        expression <span class="token operator">+=</span> n<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 非叶子结点手动加上开括号</span>
    expression <span class="token operator">+=</span> <span class="token char">'('</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归中序遍历</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    expression <span class="token operator">+=</span> n<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 子树递归完毕手动加上收括号</span>
    expression <span class="token operator">+=</span> <span class="token char">')'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

string <span class="token function">express</span><span class="token punctuation">(</span>node<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 去掉首尾多加的括号</span>
    <span class="token function">substr</span><span class="token punctuation">(</span>expression<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> expression<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="非递归遍历">非递归遍历</h3> <p><strong>递归 DFS 算法到迭代算法的转换</strong>：用栈存储访问节点，直到访问到 NULL 时开始弹栈</p> <p>中序遍历</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    stack<span class="token operator">&lt;</span>TNode<span class="token operator">*</span><span class="token operator">&gt;</span> st<span class="token punctuation">;</span>
    TNode<span class="token operator">*</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            p <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>当为先序遍历时，在<code>push</code>前执行<code>visit(p)</code>即可，而后序遍历的非递归有点复杂</p> <h3 id="宽度优先">宽度优先</h3> <p>宽度优先遍历（BFS），也叫层序遍历，维护一个队列按顺序存储访问过的结点，并且按顺序扩展已访问过的结点</p> <h2 id="由序列构造二叉树">由序列构造二叉树</h2> <p><strong>由先序、中序遍历序列构造二叉树</strong>：一个递归的过程，从先序遍历结果找到根结点，在中序序列中根据根节点位置划分左右子树，同时在先序中也找到相应左右子树位置，对子树重复这一过程，构造完整二叉树</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>TNode<span class="token operator">*</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> pre<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">&gt;</span> r1 <span class="token operator">||</span> l2 <span class="token operator">&gt;</span> r2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当序列遍历完了，返回空结点</span>
    <span class="token punctuation">}</span>
    TNode<span class="token operator">*</span> root <span class="token operator">=</span> new <span class="token function">TNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token operator">-&gt;</span>val <span class="token operator">=</span> pre<span class="token punctuation">[</span>l1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 构造根节点，一定是先序序列的第一个元素</span>
    <span class="token keyword">int</span> k<span class="token punctuation">;</span> <span class="token comment">// 在中序序列中找到根节点，左边是其左子树，右边是其右子树</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> l2<span class="token punctuation">;</span> k <span class="token operator">&gt;</span> r2<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 先序序列向后移一位，同时根据左子树结点数向后截取 k-1 个结点</span>
    <span class="token comment">// 中序序列根据根节点的位置划分成两半（不包含根节点）</span>
    root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> l1<span class="token operator">+</span>k<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2<span class="token operator">+</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造右子树</span>
    root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l1<span class="token operator">+</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> l2<span class="token operator">+</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>同理，可以用后序遍历序列和中序遍历序列构造二叉树</p> <ul><li>因为后序序列从后往前构造，倒数第一个一定是当前的根节点，然后再中序序列中进行分割左右子树</li></ul> <p>还可以通过层序遍历序列和中序遍历序列构造二叉树，和上述其实是一个道理，都是通过前者确定根节点，再在中序序列中根据根节点分割左右子树递归构造</p> <p>已知序列，手动构造二叉树并进行一系列判定</p> <img src="/assets/img/image-20230529000235686.1fb1eebb.png"> <p>选<code>C、A</code></p> <img src="/assets/img/image-20230529000814245.5e0d052a.png"> <p>手动构造，一定不要漏情况，选<code>B、B</code></p> <p>先序等于中序，即<code>根-左-右</code>等于<code>左-根-右</code>，只有可能<code>左</code>不存在时成立，故选<code>B</code></p> <img src="/assets/img/image-20230529001044865.323d3fec.png"> <h2 id="线索二叉树">线索二叉树</h2> <p>左空链指向前驱，右空链指向后继，这里的前驱和后继都是在具体的遍历方式下才存在的，也就是说不同的遍历方式下，指向的结点肯定不尽相同</p> <p>同时，为了分别到底是指的孩子还是前驱，需要设置两个标志位，若为 1 表示链为线索，指的是前驱/后继</p> <p><strong>中序</strong>线索二叉树的构造</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">inorderThread</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> cur<span class="token punctuation">,</span> TNode<span class="token operator">*</span> pre<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">inorderThread</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cur<span class="token operator">-&gt;</span>left <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        cur<span class="token operator">-&gt;</span>ltag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        pre<span class="token operator">-&gt;</span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        pre<span class="token operator">-&gt;</span>rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    <span class="token function">inorderThread</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">buildInThread</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    TNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">inorderThread</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> pre<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        pre<span class="token operator">-&gt;</span>rtag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>中序线索二叉树的遍历，好难呜呜呜</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>TNode<span class="token operator">*</span> <span class="token function">firstNode</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ltag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回根 p 的左下方结点</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

TNode<span class="token operator">*</span> <span class="token function">nextNode</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rtag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> p<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">firstNode</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>TNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">firstNode</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">nextNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>判定后序线索二叉树</p> <img src="/assets/img/image-20230529000147177.b432d9cc.png"> <p>选 D</p> <img src="/assets/img/image-20230529000323798.0d37a57f.png"> <p>选 A，后序右结点线索指向其父节点（左-右-根）</p> <p>其实可以通过写出中序序列，判断结点的前驱和后继</p> <img src="/assets/img/image-20230529000542581.cc338d6c.png"> <img src="/assets/img/image-20230529000615259.f9cdad67.png"> <p>显然其中序序列为<code>debXac</code>，故前驱为<code>b</code>后继为<code>a</code>，选 D</p> <h2 id="树、森林和二叉树">树、森林和二叉树</h2> <h3 id="树和森林的表示和转化">树和森林的表示和转化</h3> <p>把树的根节点去掉，则变成了森林（多颗独立的树）</p> <p>树的三种表示法</p> <p>双亲表示法：一个<strong>结点数组</strong>，每个结点有一个<code>next</code>指针指向自己的父节点所对应的数组下标</p> <p>存储结构如下</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>PTnode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    PTnode nodes<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">// 实际结点数</span>
<span class="token punctuation">}</span>PTree<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><img src="/assets/img/image-20230528234354217.b48bc036.png"> <p>孩子表示法：一个<strong>单链表数组</strong>，数组中每个下标上的元素都是一个链表的头节点，其实是一个子树的根结点，该根节点的链表存储了他的所有孩子节点</p> <p>在这种存储方式下，要找一个节点 a 的父节点，必须遍历所有结点链表，即找哪个结点的孩子里包含 a</p> <img src="/assets/img/image-20230528234313587.6bbf1698.png"> <p>孩子兄弟表示法：又叫二叉树表示法，二叉树的<code>left</code>结点指向其孩子结点链表的头部，<code>right</code>结点指向其兄弟结点链表的头部</p> <img src="/assets/img/image-20230528234249311.7674758c.png"> <p>树转化为二叉树：就是把树用孩子兄弟表示法表示，见上图</p> <p>森林转化为二叉树：在孩子兄弟表示法里，一颗树的最终根节点一定是没有右子树的（因为右链存兄弟，一棵树只有一个公共祖先，没有兄弟），于是在兄弟孩子表示法的基础上，把多棵树的根结点依次链在上一个根的右链上</p> <img src="/assets/img/image-20230528235004372.dbdfa721.png"> <h3 id="树和森林的遍历">树和森林的遍历</h3> <p>嗯。。就是遍历一颗二叉树，因为树和森林都可以被兄弟孩子表示法表示，只是和普通的二叉树遍历蕴含的内在含义不一样</p> <p>后根遍历：先访问孩子，后访问根</p> <ul><li>从意义上：先访问左子树（左子树为孩子链表），再访问当前根和右子树（右子树存的是根的兄弟，仍为“根”），所以叫先访问孩子后访问根</li> <li>从结构上，就是先访问左子树，后访问根，最后访问右子树</li></ul> <p>先根遍历：先访问根，后访问孩子</p> <ul><li>从意义上，其实是先访问当前根，再访问当前子树（即孩子），最后访问兄弟</li> <li>在结构上，就是先访问根，后访问左子树，最后访问右子树</li></ul> <p>分别对应了二叉树的中序遍历和先序遍历</p> <p>而森林的访问和二叉树如出一辙</p> <ul><li>先序遍历森林：先访问根，再访问第一颗树的子树，最后访问剩下的树及其子树</li> <li>中序遍历森林：先访问子树，后访问第一颗树的根，再按这一顺序访问剩下的树</li></ul> <p>三者对应关系如下</p> <table><thead><tr><th>二叉树</th> <th>树</th> <th>森林</th></tr></thead> <tbody><tr><td>中序遍历</td> <td>后根遍历</td> <td>中序遍历</td></tr> <tr><td>先序遍历</td> <td>先根遍历</td> <td>先序遍历</td></tr></tbody></table> <img src="/assets/img/image-20230529000012415.f87462ce.png"> <h2 id="树和二叉树的应用">树和二叉树的应用</h2> <h3 id="哈夫曼树">哈夫曼树</h3> <p>哈夫曼树，又叫最优二叉树，在定义上，为在给定结点权值的前提下，构造的带权路径长度最小的二叉树，可用于解决</p> <ul><li>WPL 最小化问题</li> <li>前缀编码问题</li></ul> <p>带权路径长度：对于结点而言，其带权路径长度为<code>所在深度 x 结点值</code>；对于树而言其带权路径长度为<code>叶节点的带权路径长度之和</code> <section><eqn><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><mo>×</mo><mi>d</mi><mi>e</mi><mi>e</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">
WPL = \sum_{i=1}^n w_i\times deep_i
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">ee</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></eqn></section>
其中 i 代表叶子节点</p> <p>如</p> <img src="/assets/img/image-20230530001903716.39f84191.png"> <p>的 WPL 分别为 36、46、35</p> <p>构造哈夫曼树：每次选取权值最小的两颗子树合并，合并成一颗权值为和的更大的子树，继续下一轮合并，直到只有一颗树为止</p> <img src="/assets/img/image-20230530001950218.76c7f1b9.png"> <p>哈夫曼树有以下特点</p> <ol><li>只存在度为 2 或 0 的结点</li> <li>叶子节点比非叶子结点多一个（因为<code>1</code>，根据树度和结点的性质<code>n0+n2 = 2n2+1</code> =&gt; <code>n0 = n2+1</code>）</li></ol> <h3 id="哈夫曼编码">哈夫曼编码</h3> <p>哈夫曼编码，编码，就是对一个字符采用二进制来表示，如用<code>10</code>来表示字母 a，这就是一种编码，哈夫曼编码要求在所有的编码中，任意编码不能以另一完整的编码作为前缀，即必须消除前缀编码</p> <p>这在哈夫曼树中是非常自然地可以实现的，如想左扩展的边记为 1，向右的边记为 0，则一颗哈夫曼树所有子节点对应的边的序列，就组成了一组哈夫曼编码</p> <img src="/assets/img/image-20230530002358595.6e79808f.png"> <p>在实际编码过程中，我们以字符的出现次数作为权值，自底向上构造哈夫曼树</p> <p>要注意的是，同一组结点构造的哈夫曼树可以不相同，如左右结点倒置或相同权重子树先后合并顺序不同，但可以确定的是，其 WPL 一定是最小且唯一的</p> <img src="/assets/img/image-20230530003627947.23c57354.png"> <img src="/assets/img/image-20230530003643795.bbf95fa7.png"> <p>每次选取最小权值结点自底向上构造即可，选 B；在判断前缀码时，只需要考察有无编码是另一编码的任意前缀，如此处 B 选项编码<code>0</code>是编码<code>00</code>的前缀，故不是前缀码</p> <img src="/assets/img/image-20230530003856701.6baa8bee.png"> <p>在用哈夫曼树构造哈夫曼编码时，一般都是用掉当前层的左孩子，右孩子舍去用于当下一轮编码的前缀，这样就可以向下<strong>无限扩展</strong>哈夫曼编码，但在层数一定，要求编码数量最多的情况下，可以<strong>自断手脚</strong>，用掉右孩子作为一个编码返回，故此处 4 层最多可以有 6 种编码，选 C</p> <img src="/assets/img/image-20230530004454963.0cded0cc.png"> <img src="/assets/img/image-20230530004551252.fd61e15c.png"> <p>答案依次为<code>A、D、D、D、A、C、B</code></p> <h3 id="并查集">并查集</h3> <p>树、森林的双亲表示法：即用一个数组存取结点，结点的名称为其数组下标，数组所存的值为其父节点的下标，树根无父节点，值记为 -1</p> <p>两种基本操作</p> <ul><li>查找：查找结点的根</li> <li>合并：合并子树</li></ul> <p>下图展示了一个简单的森林的并查集（S1、S2、S3）</p> <img src="/assets/img/image-20230530002737205.ad337fa9.png"> <p>在合并时，所执行的代码类似于</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> root1<span class="token punctuation">.</span> <span class="token keyword">int</span> root2<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 当两个子树独立时（不属于同一根结点）</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> root1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">find</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 将子树 2 嫁接在根 1 上，化为 root1 的孩子节点</span>
        S<span class="token punctuation">[</span>root2<span class="token punctuation">]</span> <span class="token operator">=</span> root1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>可以发现，只要不在同一颗树，子树合并的位置其实可以是任意的，不一定会合并到根部</p> <p><code>find</code>函数实现：逐步回溯找到自己的祖宗（这个函数在最坏情况复杂度为<code>O(n)</code>）</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        x <span class="token operator">=</span> S<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/28/2023, 11:05:33 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ds/basics/data-structure-stack-queue-array-string.html" class="prev">
        栈、队列、数组和串
      </a></span> <span class="next"><a href="/ds/basics/data-structure-graph.html">
        图
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/song/aries.aac" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:44px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/img/error.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/img/error.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>白羊</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>northboat</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><!----><div class="RibbonAnimation"></div><div class="Sakura" data-v-248d85d6><canvas id="canvas_sakura" style="z-index:99;" data-v-248d85d6></canvas></div></div></div>
    <script src="/assets/js/app.464b2a28.js" defer></script><script src="/assets/js/2.f539a802.js" defer></script><script src="/assets/js/1.74843084.js" defer></script><script src="/assets/js/11.e4895d61.js" defer></script>
  </body>
</html>
